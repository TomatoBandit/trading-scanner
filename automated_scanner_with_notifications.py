import os
import glob
from datetime import datetime
from typing import List, Dict, Any, Optional

import requests
import yfinance as yf
import pandas as pd
import numpy as np


class AutomatedSignalNotifier:
    """
    Daily mean-reversion scanner that:
    - Loads a watchlist (from integrated_trading_system output or fallback)
    - Scans for oversold, mean-reversion opportunities
    - Applies trend + RSI filters
    - Optionally skips trading when VIX is too high
    - Sends notifications to Discord (and prints to console)
    """

    def __init__(
        self,
        account_size: float = 1000.0,
        position_size_pct: float = 20.0,
        stop_loss_pct: float = 15.0,
        min_risk_reward: float = 0.75,
        min_profit_potential: float = 4.0,
        ma_period: int = 20,
        std_multiplier: float = 2.5,
    ):
        # Trading / risk parameters
        self.account_size = account_size
        self.position_size_pct = position_size_pct
        self.stop_loss_pct = stop_loss_pct
        self.min_risk_reward = min_risk_reward
        self.min_profit_potential = min_profit_potential
        self.ma_period = ma_period
        self.std_multiplier = std_multiplier

        # Discord webhook (from environment / GitHub secret)
        self.discord_webhook_url = os.getenv("DISCORD_WEBHOOK_URL", "").strip()

    # -------------------------------------------------------------------------
    # Watchlist loading
    # -------------------------------------------------------------------------
    def load_watchlist(self) -> List[str]:
        """
        Load the latest integrated watchlist generated by integrated_trading_system.py.
        Falls back to a small static list if none is found.
        """
        # Look for integrated_watchlist_*.txt files and pick the latest
        watchlist_files = sorted(
            glob.glob("integrated_watchlist_*.txt"), reverse=True
        )

        symbols: List[str] = []

        if watchlist_files:
            latest_file = watchlist_files[0]
            print(f"üìÇ Loading watchlist from: {latest_file}")
            with open(latest_file, "r") as f:
                for line in f:
                    sym = line.strip().upper()
                    if sym and not sym.startswith("#"):
                        symbols.append(sym)
        else:
            print("‚ö†Ô∏è No integrated_watchlist_*.txt found. Using fallback symbols.")
            symbols = [
                "SPY",
                "QQQ",
                "AAPL",
                "MSFT",
                "META",
                "AMZN",
                "GOOGL",
                "TSLA",
            ]

        symbols = sorted(set(symbols))
        print(f"üìã Watchlist symbols ({len(symbols)}): {', '.join(symbols)}")
        return symbols

    # -------------------------------------------------------------------------
    # Data & signal calculations
    # -------------------------------------------------------------------------
    def fetch_stock_data(
        self, symbol: str, period: str = "3mo", interval: str = "1d"
    ) -> Optional[pd.DataFrame]:
        """
        Fetch stock data from Yahoo Finance.
        """
        try:
            df = yf.download(
                symbol,
                period=period,
                interval=interval,
                progress=False,
                auto_adjust=True,
            )
            if df.empty:
                print(f"‚ö†Ô∏è No data for {symbol}")
                return None

            # FLATTEN POSSIBLE MULTIINDEX COLUMNS
            if isinstance(df.columns, pd.MultiIndex):
                df.columns = df.columns.get_level_values(0)

            # Keep only Close column
            if "Close" not in df.columns:
                print(f"‚ö†Ô∏è No 'Close' column for {symbol} after download.")
                return None

            df = df[["Close"]].copy()
            df.dropna(inplace=True)
            return df

        except Exception as e:
            print(f"‚ö†Ô∏è Error fetching data for {symbol}: {e}")
            return None

    def calculate_signals(
        self,
        df: pd.DataFrame,
        ma_period: int = 20,
        std_multiplier: float = 2.5,
    ) -> Optional[pd.DataFrame]:
        """
        Calculate mean reversion metrics + trend + RSI filters.
        Returns a DataFrame with the necessary columns.
        """
        # Need enough data for MA20, MA50, RSI
        min_len = max(ma_period, 50) + 5
        if len(df) < min_len:
            return None

        df = df.copy()
        df["MA_20"] = df["Close"].rolling(window=ma_period).mean()
        df["STD_20"] = df["Close"].rolling(window=ma_period).std()
        df["Threshold"] = df["MA_20"] - (std_multiplier * df["STD_20"])
        df["Below_Threshold"] = df["Close"] < df["Threshold"]
        df["Distance_from_MA"] = (df["Close"] - df["MA_20"]) / df["MA_20"] * 100

        # Trend filter (uptrend on this timeframe)
        df["MA_50"] = df["Close"].rolling(window=50).mean()
        df["Trend_OK"] = (df["Close"] > df["MA_50"]) & (df["MA_20"] > df["MA_50"])

        # RSI 14
        delta = df["Close"].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=14).mean()
        avg_loss = loss.rolling(window=14).mean()
        rs = avg_gain / avg_loss.replace(0, np.nan)
        df["RSI_14"] = 100 - (100 / (1 + rs))
        df["RSI_OK"] = df["RSI_14"] < 35  # oversold

        return df

    # -------------------------------------------------------------------------
    # VIX-based market filter
    # -------------------------------------------------------------------------
    def market_is_tradable(self, vix_threshold: float = 22.0) -> bool:
        """
        Simple VIX-based kill switch.
        Returns False in very high volatility regimes.
        """
        try:
            vix = yf.download("^VIX", period="5d", interval="1d", progress=False)
            if vix.empty:
                print("‚ö†Ô∏è Could not fetch VIX, proceeding anyway.")
                return True

            # FLATTEN POSSIBLE MULTIINDEX COLUMNS FOR VIX AS WELL
            if isinstance(vix.columns, pd.MultiIndex):
                vix.columns = vix.columns.get_level_values(0)

            if "Close" not in vix.columns:
                print("‚ö†Ô∏è No 'Close' column in VIX data. Proceeding anyway.")
                return True

            latest_vix = float(vix["Close"].iloc[-1])
            print(f"üìä Current VIX: {latest_vix:.2f}")

            if latest_vix > vix_threshold:
                print(
                    f"‚õî VIX {latest_vix:.1f} > {vix_threshold} ‚Äî skipping new trades today."
                )
                return False

            return True

        except Exception as e:
            print(f"‚ö†Ô∏è VIX check failed ({e}), proceeding without filter.")
            return True

    # -------------------------------------------------------------------------
    # Core scanning logic
    # -------------------------------------------------------------------------
    def scan_watchlist(self, symbols: List[str]) -> List[Dict[str, Any]]:
        """
        Scan the watchlist for oversold mean-reversion opportunities.
        """
        opportunities: List[Dict[str, Any]] = []

        for symbol in symbols:
            print(f"üîç Scanning {symbol}...")
            df = self.fetch_stock_data(symbol)
            if df is None:
                continue

            df = self.calculate_signals(
                df,
                ma_period=self.ma_period,
                std_multiplier=self.std_multiplier,
            )
            if df is None or df.empty:
                print(f"‚ö†Ô∏è Not enough data for {symbol} after signal calculation.")
                continue

            latest = df.iloc[-1]

            # Check for signal with filters: below threshold, uptrend, oversold
            if not latest["Below_Threshold"]:
                print(f"  ‚Ü≥ {symbol}: Not below threshold.")
                continue

            if not latest.get("Trend_OK", False):
                print(f"  ‚Ü≥ {symbol}: Trend filter not passed.")
                continue

            if not latest.get("RSI_OK", False):
                print(
                    f"  ‚Ü≥ {symbol}: RSI {latest['RSI_14']:.1f} not oversold enough."
                )
                continue

            current_price = float(latest["Close"])
            target_price = float(latest["MA_20"])

            if np.isnan(target_price) or target_price <= 0:
                print(f"  ‚Ü≥ {symbol}: Invalid MA20 target price.")
                continue

            potential_gain_pct = (target_price - current_price) / current_price * 100
            potential_gain_dollars = target_price - current_price

            # Basic risk model: fixed % stop loss
            stop_loss_price = current_price * (1 - self.stop_loss_pct / 100.0)
            risk_per_share = current_price - stop_loss_price
            reward_per_share = target_price - current_price

            if risk_per_share <= 0:
                print(f"  ‚Ü≥ {symbol}: Non-positive risk per share.")
                continue

            risk_reward_ratio = reward_per_share / risk_per_share

            # Position sizing
            position_size_dollars = self.account_size * (
                self.position_size_pct / 100.0
            )
            shares = int(position_size_dollars // current_price)
            if shares <= 0:
                print(f"  ‚Ü≥ {symbol}: Position size too small at this price.")
                continue

            if potential_gain_pct < self.min_profit_potential:
                print(
                    f"  ‚Ü≥ {symbol}: Potential gain {potential_gain_pct:.2f}% "
                    f"< {self.min_profit_potential:.2f}% min."
                )
                continue

            if risk_reward_ratio < self.min_risk_reward:
                print(
                    f"  ‚Ü≥ {symbol}: R/R {risk_reward_ratio:.2f} < "
                    f"{self.min_risk_reward:.2f} min."
                )
                continue

            print(
                f"  ‚úÖ {symbol}: Potential {potential_gain_pct:.2f}% "
                f"({potential_gain_dollars:.2f}$/share), R/R={risk_reward_ratio:.2f}, "
                f"Shares={shares}"
            )

            opportunities.append(
                {
                    "symbol": symbol,
                    "current_price": current_price,
                    "target_price": target_price,
                    "stop_loss_price": stop_loss_price,
                    "potential_gain_pct": potential_gain_pct,
                    "potential_gain_dollars": potential_gain_dollars,
                    "risk_reward_ratio": risk_reward_ratio,
                    "shares": shares,
                    "rsi": float(latest["RSI_14"]),
                    "distance_from_ma": float(latest["Distance_from_MA"]),
                }
            )

        return opportunities

    # -------------------------------------------------------------------------
    # Discord notification
    # -------------------------------------------------------------------------
    def build_discord_embed(self, opportunities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Build a Discord embed payload describing the opportunities.
        """
        now_str = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")

        description_lines = []
        for opp in opportunities:
            sym = opp["symbol"]
            cp = opp["current_price"]
            tp = opp["target_price"]
            sl = opp["stop_loss_price"]
            rr = opp["risk_reward_ratio"]
            pg = opp["potential_gain_pct"]
            shares = opp["shares"]
            rsi = opp["rsi"]

            line = (
                f"**{sym}**  |  Price: `${cp:.2f}`  ‚Üí Target: `${tp:.2f}`  "
                f"Stop: `${sl:.2f}`  |  Gain: `{pg:.1f}%`  |  "
                f"R/R: `{rr:.2f}`  |  Shares: `{shares}`  |  RSI: `{rsi:.1f}`"
            )
            description_lines.append(line)

        embed = {
            "title": "üìä Mean Reversion Opportunities",
            "description": "\n".join(description_lines),
            "color": 0x00FFAA,
            "footer": {"text": f"Scan time: {now_str}"},
        }

        return {"embeds": [embed]}

    def send_discord_notification(self, opportunities: List[Dict[str, Any]]) -> None:
        """
        Send results to Discord via webhook.
        """
        if not self.discord_webhook_url:
            print("‚ö†Ô∏è DISCORD_WEBHOOK_URL not set. Skipping Discord notification.")
            return

        payload = self.build_discord_embed(opportunities)

        try:
            response = requests.post(self.discord_webhook_url, json=payload, timeout=10)
            if response.status_code == 204:
                print("‚úÖ Discord notification sent successfully.")
            else:
                print(
                    f"‚ö†Ô∏è Discord notification failed: {response.status_code} "
                    f"{response.text}"
                )
        except Exception as e:
            print(f"‚ö†Ô∏è Error sending Discord notification: {e}")

    # -------------------------------------------------------------------------
    # Email notification (stub ‚Äì safe no-op unless you wire it up)
    # -------------------------------------------------------------------------
    def send_email_notification(self, opportunities: List[Dict[str, Any]]) -> None:
        """
        Stub for email notifications.
        Currently prints a message instead of sending real emails.
        """
        print("‚ÑπÔ∏è Email notification not configured. Skipping.")

    # -------------------------------------------------------------------------
    # Orchestrator
    # -------------------------------------------------------------------------
    def run_automated_scan(self) -> List[Dict[str, Any]]:
        """
        Run the full automated scan with notifications.
        Returns the list of opportunities.
        """
        print("üöÄ Starting automated scan...")

        # VIX-based kill switch
        if not self.market_is_tradable():
            print("üõë Market conditions not suitable (high VIX). No scan run.")
            return []

        watchlist = self.load_watchlist()
        if not watchlist:
            print("‚ö†Ô∏è Watchlist is empty. Nothing to scan.")
            return []

        print(f"üìä Scanning {len(watchlist)} symbols from watchlist...")
        opportunities = self.scan_watchlist(watchlist)

        if opportunities:
            print(f"‚úÖ Found {len(opportunities)} qualifying opportunities.")
            # Discord
            try:
                self.send_discord_notification(opportunities)
            except Exception as e:
                print(f"‚ö†Ô∏è Discord notification error: {e}")

            # Email (currently stub)
            try:
                self.send_email_notification(opportunities)
            except Exception as e:
                print(f"‚ö†Ô∏è Email notification error: {e}")
        else:
            print("‚ÑπÔ∏è No qualifying opportunities found today.")
            opportunities = []

        print("‚úÖ Scan complete.")
        return opportunities


# -------------------------------------------------------------------------
# Entry point
# -------------------------------------------------------------------------
def main() -> int:
    notifier = AutomatedSignalNotifier()
    opportunities = notifier.run_automated_scan()

    if opportunities:
        print(f"üéØ {len(opportunities)} opportunities found.")
    else:
        print("‚ÑπÔ∏è No opportunities found. Scan completed successfully.")

    # Always return 0 so CI doesn't treat "no trades" as a failure.
    return 0

if __name__ == "__main__":
    exit(main())
