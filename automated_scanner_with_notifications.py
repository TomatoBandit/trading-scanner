import os
import glob
from datetime import datetime
from typing import List, Dict, Any, Optional

import requests
import yfinance as yf
import pandas as pd
import numpy as np


class AutomatedSignalNotifier:
    """
    Daily mean-reversion scanner that:
    - Loads a watchlist (from integrated_trading_system output or fallback)
    - Scans for oversold, mean-reversion opportunities
    - Applies trend + RSI filters
    - Optionally skips trading when VIX is too high
    - Sends notifications to Discord (and prints to console)
    - (NEW) Logs signals to Google Sheets via Apps Script webhook
    """

    def __init__(
        self,
        account_size: float = 1000.0,
        position_size_pct: float = 20.0,
        stop_loss_pct: float = 15.0,
        min_risk_reward: float = 0.75,
        min_profit_potential: float = 4.0,
        ma_period: int = 20,
        std_multiplier: float = 2.5,
    ):
        # Trading / risk parameters
        self.account_size = account_size
        self.position_size_pct = position_size_pct
        self.stop_loss_pct = stop_loss_pct
        self.min_risk_reward = min_risk_reward
        self.min_profit_potential = min_profit_potential
        self.ma_period = ma_period
        self.std_multiplier = std_multiplier

        # Discord webhook (from environment / GitHub secret)
        self.discord_webhook_url = os.getenv("DISCORD_WEBHOOK_URL", "").strip()

        # NEW: Google Sheets webhook URL (Apps Script web app)
        self.sheets_webhook_url = os.getenv("SHEETS_WEBHOOK_URL", "").strip()

        # NEW: last seen VIX value (for logging context)
        self.last_vix: Optional[float] = None

    # -------------------------------------------------------------------------
    # Watchlist loading
    # -------------------------------------------------------------------------
    def load_watchlist(self) -> List[str]:
        """
        Load the latest integrated watchlist generated by integrated_trading_system.py.
        Prefer root-level 'integrated_watchlist_latest.txt', then fall back
        to older integrated_watchlist_*.txt patterns, then a tiny static list.
        """
        symbols: List[str] = []

        # 1) Preferred: explicit "latest" file at repo root
        latest_path = "integrated_watchlist_latest.txt"
        if os.path.exists(latest_path):
            print(f"üìÇ Loading watchlist from: {latest_path}")
            with open(latest_path, "r") as f:
                for line in f:
                    sym = line.strip().upper()
                    if sym and not sym.startswith("#"):
                        symbols.append(sym)
        else:
            # 2) Legacy behavior: search for integrated_watchlist_*.txt in root
            watchlist_files = sorted(
                glob.glob("integrated_watchlist_*.txt"), reverse=True
            )
            if watchlist_files:
                latest_file = watchlist_files[0]
                print(f"üìÇ Loading watchlist from: {latest_file}")
                with open(latest_file, "r") as f:
                    for line in f:
                        sym = line.strip().upper()
                        if sym and not sym.startswith("#"):
                            symbols.append(sym)
            else:
                print("‚ö†Ô∏è No integrated_watchlist files found. Using fallback symbols.")
                symbols = [
                    "SPY",
                    "QQQ",
                    "AAPL",
                    "MSFT",
                    "META",
                    "AMZN",
                    "GOOGL",
                    "TSLA",
                ]

        symbols = sorted(set(symbols))
        print(f"üìã Watchlist symbols ({len(symbols)}): {', '.join(symbols)}")
        return symbols

    # -------------------------------------------------------------------------
    # Data & signal calculations
    # -------------------------------------------------------------------------
    def fetch_stock_data(
        self, symbol: str, period: str = "3mo", interval: str = "1d"
    ) -> Optional[pd.DataFrame]:
        """
        Fetch stock data from Yahoo Finance.
        """
        try:
            df = yf.download(
                symbol,
                period=period,
                interval=interval,
                progress=False,
                auto_adjust=True,
            )
            if df.empty:
                print(f"‚ö†Ô∏è No data for {symbol}")
                return None

            # Flatten possible MultiIndex columns
            if isinstance(df.columns, pd.MultiIndex):
                df.columns = df.columns.get_level_values(0)

            if "Close" not in df.columns:
                print(f"‚ö†Ô∏è No 'Close' column for {symbol} after download.")
                return None

            df = df[["Close"]].copy()
            df.dropna(inplace=True)
            return df

        except Exception as e:
            print(f"‚ö†Ô∏è Error fetching data for {symbol}: {e}")
            return None

    def calculate_signals(
        self,
        df: pd.DataFrame,
        ma_period: int = 20,
        std_multiplier: float = 2.5,
    ) -> Optional[pd.DataFrame]:
        """
        Calculate mean reversion metrics + trend + RSI filters.
        Returns a DataFrame with the necessary columns.
        """
        min_len = max(ma_period, 50) + 5
        if len(df) < min_len:
            return None

        df = df.copy()
        df["MA_20"] = df["Close"].rolling(window=ma_period).mean()
        df["STD_20"] = df["Close"].rolling(window=ma_period).std()
        df["Threshold"] = df["MA_20"] - (std_multiplier * df["STD_20"])
        df["Below_Threshold"] = df["Close"] < df["Threshold"]
        df["Distance_from_MA"] = (df["Close"] - df["MA_20"]) / df["MA_20"] * 100

        # Trend filter (uptrend)
        df["MA_50"] = df["Close"].rolling(window=50).mean()
        df["Trend_OK"] = (df["Close"] > df["MA_50"]) & (df["MA_20"] > df["MA_50"])

        # RSI 14
        delta = df["Close"].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=14).mean()
        avg_loss = loss.rolling(window=14).mean()
        rs = avg_gain / avg_loss.replace(0, np.nan)
        df["RSI_14"] = 100 - (100 / (1 + rs))
        df["RSI_OK"] = df["RSI_14"] < 35

        return df

    # -------------------------------------------------------------------------
    # VIX-based market filter
    # -------------------------------------------------------------------------
    def market_is_tradable(self, vix_threshold: float = 22.0) -> bool:
        """
        Simple VIX-based kill switch.
        Returns False in very high volatility regimes.
        Also stores the last seen VIX for logging.
        """
        try:
            vix = yf.download("^VIX", period="5d", interval="1d", progress=False)
            if vix.empty:
                print("‚ö†Ô∏è Could not fetch VIX, proceeding anyway.")
                self.last_vix = None
                return True

            if isinstance(vix.columns, pd.MultiIndex):
                vix.columns = vix.columns.get_level_values(0)

            if "Close" not in vix.columns:
                print("‚ö†Ô∏è No 'Close' column in VIX data. Proceeding anyway.")
                self.last_vix = None
                return True

            latest_vix = float(vix["Close"].iloc[-1])
            self.last_vix = latest_vix
            print(f"üìä Current VIX: {latest_vix:.2f}")

            if latest_vix > vix_threshold:
                print(
                    f"‚õî VIX {latest_vix:.1f} > {vix_threshold} ‚Äî "
                    "skipping new trades today."
                )
                return False

            return True

        except Exception as e:
            print(f"‚ö†Ô∏è VIX check failed ({e}), proceeding without filter.")
            self.last_vix = None
            return True

    # -------------------------------------------------------------------------
    # Core scanning logic
    # -------------------------------------------------------------------------
    def scan_watchlist(self, symbols: List[str]) -> List[Dict[str, Any]]:
        """
        Scan the watchlist for oversold mean-reversion opportunities.
        """
        opportunities: List[Dict[str, Any]] = []

        for symbol in symbols:
            print(f"üîç Scanning {symbol}...")
            df = self.fetch_stock_data(symbol)
            if df is None:
                continue

            df = self.calculate_signals(
                df,
                ma_period=self.ma_period,
                std_multiplier=self.std_multiplier,
            )
            if df is None or df.empty:
                print(f"‚ö†Ô∏è Not enough data for {symbol} after signal calculation.")
                continue

            latest = df.iloc[-1]

            if not latest["Below_Threshold"]:
                print(f"  ‚Ü≥ {symbol}: Not below threshold.")
                continue

            if not latest.get("Trend_OK", False):
                print(f"  ‚Ü≥ {symbol}: Trend filter not passed.")
                continue

            if not latest.get("RSI_OK", False):
                print(
                    f"  ‚Ü≥ {symbol}: RSI {latest['RSI_14']:.1f} not oversold enough."
                )
                continue

            current_price = float(latest["Close"])
            target_price = float(latest["MA_20"])

            if np.isnan(target_price) or target_price <= 0:
                print(f"  ‚Ü≥ {symbol}: Invalid MA20 target price.")
                continue

            potential_gain_pct = (target_price - current_price) / current_price * 100
            potential_gain_dollars = target_price - current_price

            stop_loss_price = current_price * (1 - self.stop_loss_pct / 100.0)
            risk_per_share = current_price - stop_loss_price
            reward_per_share = target_price - current_price

            if risk_per_share <= 0:
                print(f"  ‚Ü≥ {symbol}: Non-positive risk per share.")
                continue

            risk_reward_ratio = reward_per_share / risk_per_share

            position_size_dollars = self.account_size * (
                self.position_size_pct / 100.0
            )
            shares = int(position_size_dollars // current_price)
            if shares <= 0:
                print(f"  ‚Ü≥ {symbol}: Position size too small at this price.")
                continue

            if potential_gain_pct < self.min_profit_potential:
                print(
                    f"  ‚Ü≥ {symbol}: Potential gain {potential_gain_pct:.2f}% "
                    f"< {self.min_profit_potential:.2f}% min."
                )
                continue

            if risk_reward_ratio < self.min_risk_reward:
                print(
                    f"  ‚Ü≥ {symbol}: R/R {risk_reward_ratio:.2f} < "
                    f"{self.min_risk_reward:.2f} min."
                )
                continue

            print(
                f"  ‚úÖ {symbol}: Potential {potential_gain_pct:.2f}% "
                f"({potential_gain_dollars:.2f}$/share), R/R={risk_reward_ratio:.2f}, "
                f"Shares={shares}"
            )

            opportunities.append(
                {
                    "symbol": symbol,
                    "current_price": current_price,
                    "target_price": target_price,
                    "stop_loss_price": stop_loss_price,
                    "potential_gain_pct": potential_gain_pct,
                    "potential_gain_dollars": potential_gain_dollars,
                    "risk_reward_ratio": risk_reward_ratio,
                    "shares": shares,
                    "rsi": float(latest["RSI_14"]),
                    "distance_from_ma": float(latest["Distance_from_MA"]),
                }
            )

        return opportunities

    # -------------------------------------------------------------------------
    # Discord notifications
    # -------------------------------------------------------------------------
    def build_discord_embed(self, opportunities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Build a Discord embed payload describing the opportunities.
        """
        now_str = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")

        description_lines = []
        for opp in opportunities:
            sym = opp["symbol"]
            cp = opp["current_price"]
            tp = opp["target_price"]
            sl = opp["stop_loss_price"]
            rr = opp["risk_reward_ratio"]
            pg = opp["potential_gain_pct"]
            shares = opp["shares"]
            rsi = opp["rsi"]

            line = (
                f"**{sym}**  |  Price: `${cp:.2f}`  ‚Üí Target: `${tp:.2f}`  "
                f"Stop: `${sl:.2f}`  |  Gain: `{pg:.1f}%`  |  "
                f"R/R: `{rr:.2f}`  |  Shares: `{shares}`  |  RSI: `{rsi:.1f}`"
            )
            description_lines.append(line)

        embed = {
            "title": "üìä Mean Reversion Opportunities",
            "description": "\n".join(description_lines),
            "color": 0x00FFAA,
            "footer": {"text": f"Scan time: {now_str}"},
        }

        return {"embeds": [embed]}

    def send_discord_notification(self, opportunities: List[Dict[str, Any]]) -> None:
        """
        Send results to Discord via webhook.
        """
        if not self.discord_webhook_url:
            print("‚ö†Ô∏è DISCORD_WEBHOOK_URL not set. Skipping Discord notification.")
            return

        payload = self.build_discord_embed(opportunities)

        try:
            response = requests.post(self.discord_webhook_url, json=payload, timeout=10)
            if response.status_code == 204:
                print("‚úÖ Discord notification sent successfully.")
            else:
                print(
                    f"‚ö†Ô∏è Discord notification failed: {response.status_code} "
                    f"{response.text}"
                )
        except Exception as e:
            print(f"‚ö†Ô∏è Error sending Discord notification: {e}")

    def send_discord_no_opportunities(self) -> None:
        """
        Send a simple heartbeat message to Discord when no opportunities are found.
        """
        if not self.discord_webhook_url:
            print(
                "‚ö†Ô∏è DISCORD_WEBHOOK_URL not set. Skipping Discord 'no-opps' notification."
            )
            return

        now_str = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        payload = {
            "embeds": [
                {
                    "title": "üì≠ No Mean Reversion Setups Today",
                    "description": (
                        "The scanner ran successfully but did not find any qualifying "
                        "opportunities based on the current filters."
                    ),
                    "color": 0x888888,
                    "footer": {"text": f"Scan time: {now_str}"},
                }
            ]
        }

        try:
            response = requests.post(self.discord_webhook_url, json=payload, timeout=10)
            if response.status_code in (200, 204):
                print("‚úÖ Discord 'no opportunities' notification sent successfully.")
            else:
                print(
                    f"‚ö†Ô∏è Discord 'no opportunities' notification failed: "
                    f"{response.status_code} {response.text}"
                )
        except Exception as e:
            print(f"‚ö†Ô∏è Error sending 'no opportunities' Discord notification: {e}")

    # -------------------------------------------------------------------------
    # Google Sheets logging
    # -------------------------------------------------------------------------
    def log_signals_to_google_sheets(self, opportunities: List[Dict[str, Any]]) -> None:
        """
        Send today's opportunities to Google Sheets via Apps Script webhook.
        Each opportunity becomes one row.
        """
        if not opportunities:
            print("‚ÑπÔ∏è No opportunities to log to Google Sheets.")
            return

        if not self.sheets_webhook_url:
            print("‚ö†Ô∏è SHEETS_WEBHOOK_URL not set. Skipping Google Sheets logging.")
            return

        timestamp_utc = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        vix_value = float(self.last_vix) if self.last_vix is not None else None

        rows = []
        for opp in opportunities:
            rows.append(
                {
                    "timestamp_utc": timestamp_utc,
                    "symbol": opp["symbol"],
                    "current_price": opp["current_price"],
                    "target_price": opp["target_price"],
                    "stop_loss_price": opp["stop_loss_price"],
                    "suggested_shares": opp["shares"],
                    "potential_gain_pct": opp["potential_gain_pct"],
                    "risk_reward_ratio": opp["risk_reward_ratio"],
                    "rsi_14": opp["rsi"],
                    "distance_from_ma": opp["distance_from_ma"],
                    "vix": vix_value,
                    "account_size": self.account_size,
                    "position_size_pct": self.position_size_pct,
                    "notes": "",
                }
            )

        payload = {"rows": rows}

        try:
            resp = requests.post(self.sheets_webhook_url, json=payload, timeout=10)
            if resp.status_code in (200, 204):
                print("‚úÖ Logged opportunities to Google Sheets.")
            else:
                print(
                    f"‚ö†Ô∏è Google Sheets logging failed: "
                    f"{resp.status_code} {resp.text}"
                )
        except Exception as e:
            print(f"‚ö†Ô∏è Error logging to Google Sheets: {e}")

    # -------------------------------------------------------------------------
    # Email stub
    # -------------------------------------------------------------------------
    def send_email_notification(self, opportunities: List[Dict[str, Any]]) -> None:
        """
        Stub for email notifications.
        Currently prints a message instead of sending real emails.
        """
        print("‚ÑπÔ∏è Email notification not configured. Skipping.")

    # -------------------------------------------------------------------------
    # Orchestrator
    # -------------------------------------------------------------------------
    def run_automated_scan(self) -> List[Dict[str, Any]]:
        """
        Run the full automated scan with notifications.
        Returns the list of opportunities.
        """
        print("üöÄ Starting automated scan...")

        # VIX-based kill switch
        if not self.market_is_tradable():
            print("üõë Market conditions not suitable (high VIX). No scan run.")
            return []

        watchlist = self.load_watchlist()
        if not watchlist:
            print("‚ö†Ô∏è Watchlist is empty. Nothing to scan.")
            return []

        print(f"üìä Scanning {len(watchlist)} symbols from watchlist...")
        opportunities = self.scan_watchlist(watchlist)

        if opportunities:
            print(f"‚úÖ Found {len(opportunities)} qualifying opportunities.")
            try:
                self.send_discord_notification(opportunities)
            except Exception as e:
                print(f"‚ö†Ô∏è Discord notification error: {e}")

            try:
                self.send_email_notification(opportunities)
            except Exception as e:
                print(f"‚ö†Ô∏è Email notification error: {e}")

            # NEW: log to Google Sheets
            try:
                self.log_signals_to_google_sheets(opportunities)
            except Exception as e:
                print(f"‚ö†Ô∏è Google Sheets logging error: {e}")
        else:
            print("‚ÑπÔ∏è No qualifying opportunities found today.")
            opportunities = []
            try:
                self.send_discord_no_opportunities()
            except Exception as e:
                print(f"‚ö†Ô∏è Discord 'no opportunities' notification error: {e}")

        print("‚úÖ Scan complete.")
        return opportunities


# -------------------------------------------------------------------------
# Entry point
# -------------------------------------------------------------------------
def main() -> int:
    notifier = AutomatedSignalNotifier()
    notifier.run_automated_scan()
    # Always return 0 so CI doesn't treat 'no trades' as failure
    return 0


if __name__ == "__main__":
    exit(main())
